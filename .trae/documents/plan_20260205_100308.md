I have prioritized the performance improvements into actionable tasks, ranked by impact and dependency.

## **Prioritized Implementation Tasks**

### **Task 1: Optimize Mouse Interaction Handling (High Impact / Low Effort)**
*Goal: Stop the application from re-rendering on every pixel of mouse movement.*
1.  **Modify `handleMouseMove`**: Add conditional checks to ensure `setSelectedObject` and `setSelectedSeats` are only called when the value *actually* changes.
2.  **Benefit**: Immediately reduces CPU usage during hovering and dragging, making the UI feel more responsive.

### **Task 2: Implement Layered Rendering / Caching (Critical for "Huge" Maps)**
*Goal: Avoid drawing 10,000+ shapes every frame.*
1.  **Create Offscreen Canvas**: Initialize a `staticCanvasRef` to store the rendered base map.
2.  **Split Rendering Logic**:
    -   `renderStaticLayer()`: Draws zones, rows, and unselected seats to the offscreen canvas. Only runs when `seatData` or `zoom` changes.
    -   `drawSeatMap()`: Clears the main canvas, draws the cached `staticLayer`, then draws *only* the dynamic elements (highlights, selection box).
3.  **Benefit**: Dragging a selection box becomes O(1) operation instead of O(N), ensuring 60 FPS even with huge maps.

### **Task 3: Optimize Data Access (Medium Impact)**
*Goal: Speed up the static rendering loop.*
1.  **Category Lookup Map**: Create a `Map<string, string>` for category colors to replace the `array.find` operation inside the nested render loops.
2.  **Benefit**: Reduces the computational overhead of the initial render and static updates.

I will proceed with these tasks in this order to deliver the most significant improvements first.